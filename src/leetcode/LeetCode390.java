package leetcode;

/**
 * @ClassName LeetCode390
 * @Description TODO
 * @Author: 索德文
 * @date 2022/1/2 12:42
 * @Version 1.0
 */
public class LeetCode390 {
    /*
    本题其实就是约瑟夫环的具体应用
    对于本题，定义 f[i]f[i] 为在 连续序列 [1, i][1,i] 中进行「起始从左到右」的轮流换向间隔删除，最终左边剩余的编号；定义 f'[i] 为在 连续序列 [1, i] 中进行「起始从右到左」的轮流换向间隔删除，最终左边剩余的编号。
    由于「从左往右」和「从右往左」分别为「从左端点发起，间隔删除」和「从右端点发起，间隔删除」，因此整个删除过程在连续序列中 [1, i] 中具有对称性，两者最终剩余的编号在连续序列中也具有对称性。
    即可得出第一个公式：
    f[i] + f'[i] = i + 1
    考虑题目规定的「左右轮流进行发起删除」的操作如何进行。
    由于我们对 f[i] 和 f'[i] 的定义都是「连续序列」，因此如果我们希望使用 f[i] 和 f'[i]得出最终答案，我们需要在每次消除后对序列进行「重新编号」，确保能够使用 f[i] 和 f'[i] 作为合法状态值，
    在计算出「重新编号」后的，需要将答案（编号）映射回去重新编号前的值。起始时，我们对连续序列 [1,2,3,...,i] 执行了一次「从左往右」的消除之后，得到的序列为 [2,4,6,...,x]（其中 x 根据 i 的奇偶性不同，
    可能为 i 或 i−1）。新序列的长度为 [i/2]
    考虑对得到的序列进行重新编号，使其继续保有「连续序列」的定义，即变为 [1,2,3,...,[i/2]]，然后执行「从右往左」的间隔删除，最终得到 f′[i/2]，之后考虑将答案编号映射回「重新编号」前的值。
    此时可得到第二个公式：
    f[i]=f′[i/2]∗2
    通过上述两个公式，我们可以将 f′[i] 进行消除，得到最终的 f[i] 关系式：
    f[i]=2∗(i/2+1−f[i/2])
    我们知道需要实现的函数 lastRemaining 其实就是 f[i]f[i]，因此该递推过程我们可以使用递归进行实现（注意的出口条件 f[1] = 1f[1]=1）。
     */
    public int lastRemaining(int n) {
        return n == 1 ? 1 : 2 * (n / 2 + 1 - lastRemaining(n / 2));
    }
}
